#+TITLE: Vulpea v2 Implementation Guide
#+AUTHOR: Boris Buliga
#+DATE: 2025-11-16

* Getting Started

This guide provides step-by-step instructions for implementing Vulpea v2. Read =v2-architecture-decisions.org= first for context and rationale.

* Development Setup

** Prerequisites
- Emacs 27.1+
- SQLite 3.38+ (for JSON functions)
- Eldev (already configured)
- Git

** Environment Setup
#+begin_src bash
# Clone if needed
git clone https://github.com/d12frosted/vulpea.git
cd vulpea

# Create v2 branch
git checkout -b v2-rewrite

# Run existing tests to ensure environment works
eldev test

# Check dependencies
eldev -p -dtT exec emacs --version
sqlite3 --version
#+end_src

** Directory Structure
#+begin_example
vulpea/
â”œâ”€â”€ vulpea.el                    # Main API (to be rewritten)
â”œâ”€â”€ vulpea-db.el                 # Database core (NEW)
â”œâ”€â”€ vulpea-db-query.el           # Query builders (NEW)
â”œâ”€â”€ vulpea-db-extract.el         # Core extractors (NEW)
â”œâ”€â”€ vulpea-sync.el               # File watching (port from PR#194)
â”œâ”€â”€ vulpea-note.el               # Note struct (simplify)
â”œâ”€â”€ vulpea-select.el             # Completion (mostly keep)
â”œâ”€â”€ vulpea-buffer.el             # Buffer ops (mostly keep)
â”œâ”€â”€ vulpea-meta.el               # Meta ops (mostly keep)
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ vulpea-db-test.el        # Database tests (NEW)
â”‚   â”œâ”€â”€ vulpea-db-query-test.el  # Query tests (NEW)
â”‚   â”œâ”€â”€ vulpea-sync-test.el      # Sync tests (NEW)
â”‚   â””â”€â”€ vulpea-perf-test.el      # Performance (expand)
â””â”€â”€ docs/
    â”œâ”€â”€ v2-architecture-decisions.org
    â””â”€â”€ v2-implementation-guide.org
#+end_example

* Phase 1: Database Core

** Step 1.1: Schema Definition

Create =vulpea-db.el= with schema constants:

#+begin_src elisp
;;; vulpea-db.el --- Database layer for Vulpea v2 -*- lexical-binding: t; -*-

(require 'emacsql)
(require 'emacsql-sqlite)

(defconst vulpea-db-version 2
  "Current database schema version.")

(defconst vulpea-db--schema
  '(;; Materialized view table
    (notes
     [(id :not-null :primary-key)
      (path :not-null)
      (level :not-null)
      (pos :not-null)
      (title :not-null)
      (properties :not-null)
      (tags)
      (aliases)
      (meta)
      (links)
      (todo)
      (priority)
      (scheduled)
      (deadline)
      (closed)
      (outline-path)
      (attach-dir)
      (created-at)
      (modified-at :not-null)]
     (:unique [path level pos]))

    ;; Normalized tables
    (tags
     [(note-id :not-null)
      (tag :not-null)]
     (:primary-key [note-id tag])
     (:foreign-key [note-id] :references notes [id] :on-delete :cascade))

    (links
     [(source :not-null)
      (dest :not-null)
      (type :not-null)]
     (:primary-key [source dest type])
     (:foreign-key [source] :references notes [id] :on-delete :cascade))

    (meta
     [(note-id :not-null)
      (key :not-null)
      (value :not-null)
      (type)]
     (:foreign-key [note-id] :references notes [id] :on-delete :cascade))

    (files
     [(path :not-null :primary-key)
      (hash :not-null)
      (mtime :not-null)
      (size :not-null)])

    (schema-registry
     [(name :not-null :primary-key)
      (version :not-null)
      (created-at :not-null)])))

(defconst vulpea-db--indices
  '((idx-tags-tag tags [tag])
    (idx-tags-note tags [note-id])
    (idx-links-dest links [dest])
    (idx-links-source links [source])
    (idx-meta-key meta [key])
    (idx-meta-note meta [note-id])
    (idx-notes-path notes [path])
    (idx-notes-title notes [title])
    (idx-notes-modified notes [modified-at])))

(defvar vulpea-db--connection nil
  "Database connection.")

(defun vulpea-db ()
  "Return database connection, creating if necessary."
  (unless (and vulpea-db--connection
               (emacsql-live-p vulpea-db--connection))
    (setq vulpea-db--connection (vulpea-db--init)))
  vulpea-db--connection)

(provide 'vulpea-db)
#+end_src

** Step 1.2: Database Initialization

Add initialization functions:

#+begin_src elisp
(defcustom vulpea-db-location
  (expand-file-name "vulpea.db" user-emacs-directory)
  "Location of Vulpea database."
  :type 'file
  :group 'vulpea-db)

(defun vulpea-db--init ()
  "Initialize database connection and schema."
  (let ((db (emacsql-sqlite vulpea-db-location)))
    ;; Enable foreign keys
    (emacsql db [:pragma (= foreign-keys on)])

    ;; Create tables if needed
    (vulpea-db--create-tables db)

    ;; Create indices
    (vulpea-db--create-indices db)

    ;; Register schema version
    (vulpea-db--register-schema db 'core vulpea-db-version)

    db))

(defun vulpea-db--create-tables (db)
  "Create all tables in DB if they don't exist."
  (dolist (table-spec vulpea-db--schema)
    (emacsql db [:create-table :if-not-exists $i1 $S2]
             (car table-spec)
             (cdr table-spec))))

(defun vulpea-db--create-indices (db)
  "Create all indices in DB if they don't exist."
  (dolist (index-spec vulpea-db--indices)
    (pcase-let ((`(,name ,table ,columns) index-spec))
      (emacsql db [:create-index :if-not-exists $i1 :on $i2 $S3]
               name table columns))))

(defun vulpea-db--register-schema (db name version)
  "Register schema NAME with VERSION in DB."
  (emacsql db [:insert :or :replace :into schema-registry
               :values $v1]
           (vector (vector (symbol-name name)
                          version
                          (format-time-string "%Y-%m-%d %H:%M:%S")))))

(defun vulpea-db--table-exists-p (table)
  "Check if TABLE exists in database."
  (let ((result (emacsql (vulpea-db)
                         [:select name :from sqlite-master
                          :where (and (= type 'table)
                                     (= name $s1))]
                         (symbol-name table))))
    (not (null result))))

(defun vulpea-db--index-exists-p (index)
  "Check if INDEX exists in database."
  (let ((result (emacsql (vulpea-db)
                         [:select name :from sqlite-master
                          :where (and (= type 'index)
                                     (= name $s1))]
                         (symbol-name index))))
    (not (null result))))
#+end_src

** Step 1.3: Basic CRUD Operations

#+begin_src elisp
(cl-defun vulpea-db--insert-note (&key id path level pos title
                                       properties tags aliases meta links
                                       todo priority scheduled deadline
                                       closed outline-path attach-dir
                                       created-at modified-at)
  "Insert note into database.
Updates both materialized notes table and normalized tables."
  (let ((db (vulpea-db)))
    (emacsql-with-transaction db
      ;; 1. Insert into materialized notes table
      (emacsql db [:insert :into notes :values $v1]
               (vector
                (vector id path level pos title
                        (json-encode properties)
                        (json-encode tags)
                        (json-encode aliases)
                        (json-encode meta)
                        (json-encode links)
                        todo priority scheduled deadline closed
                        outline-path attach-dir
                        created-at modified-at)))

      ;; 2. Insert into normalized tags table
      (when tags
        (emacsql db [:insert :into tags :values $v1]
                 (mapcar (lambda (tag) (vector id tag)) tags)))

      ;; 3. Insert into normalized links table
      (when links
        (emacsql db [:insert :into links :values $v1]
                 (mapcar (lambda (link)
                           (vector id
                                   (plist-get link :dest)
                                   (plist-get link :type)))
                         links)))

      ;; 4. Insert into normalized meta table
      (when meta
        (emacsql db [:insert :into meta :values $v1]
                 (cl-loop for (key . values) in meta
                          append (mapcar (lambda (v)
                                           (vector id key
                                                   (plist-get v :value)
                                                   (plist-get v :type)))
                                         values)))))))

(defun vulpea-db--delete-file-notes (path)
  "Delete all notes from PATH.
Cascades to normalized tables automatically."
  (emacsql (vulpea-db)
           [:delete :from notes :where (= path $s1)]
           path))

(defun vulpea-db--update-file-hash (path hash mtime size)
  "Update file tracking info for PATH."
  (emacsql (vulpea-db)
           [:insert :or :replace :into files :values $v1]
           (vector (vector path hash mtime size))))
#+end_src

** Step 1.4: Write Tests

Create =test/vulpea-db-test.el=:

#+begin_src elisp
;;; vulpea-db-test.el --- Tests for vulpea-db -*- lexical-binding: t; -*-

(require 'ert)
(require 'vulpea-db)

(defmacro vulpea-test--with-temp-db (&rest body)
  "Execute BODY with temporary database."
  (declare (indent 0))
  `(let* ((temp-file (make-temp-file "vulpea-test-" nil ".db"))
          (vulpea-db-location temp-file)
          (vulpea-db--connection nil))
     (unwind-protect
         (progn ,@body)
       (when vulpea-db--connection
         (emacsql-close vulpea-db--connection))
       (when (file-exists-p temp-file)
         (delete-file temp-file)))))

(ert-deftest vulpea-db-init ()
  "Test database initialization."
  (vulpea-test--with-temp-db
    (let ((db (vulpea-db)))
      (should (emacsql-live-p db))
      ;; Check foreign keys enabled
      (should (equal (caar (emacsql db [:pragma foreign-keys]))
                     1)))))

(ert-deftest vulpea-db-schema-creation ()
  "Test all tables and indices are created."
  (vulpea-test--with-temp-db
    (vulpea-db)  ; Initialize

    ;; Check tables
    (should (vulpea-db--table-exists-p 'notes))
    (should (vulpea-db--table-exists-p 'tags))
    (should (vulpea-db--table-exists-p 'links))
    (should (vulpea-db--table-exists-p 'meta))
    (should (vulpea-db--table-exists-p 'files))
    (should (vulpea-db--table-exists-p 'schema-registry))

    ;; Check indices
    (should (vulpea-db--index-exists-p 'idx-tags-tag))
    (should (vulpea-db--index-exists-p 'idx-links-dest))
    (should (vulpea-db--index-exists-p 'idx-meta-key))))

(ert-deftest vulpea-db-insert-note-basic ()
  "Test basic note insertion."
  (vulpea-test--with-temp-db
    (vulpea-db)
    (vulpea-db--insert-note
     :id "test-id"
     :path "/tmp/test.org"
     :level 0
     :pos 0
     :title "Test Note"
     :properties '((foo . "bar"))
     :tags '("tag1" "tag2")
     :modified-at "2025-11-16 10:00:00")

    ;; Verify in notes table
    (let ((row (caar (emacsql (vulpea-db)
                              [:select [id title] :from notes
                               :where (= id $s1)]
                              "test-id"))))
      (should (equal row '("test-id" "Test Note"))))))

(ert-deftest vulpea-db-insert-note-normalized-tables ()
  "Test note insertion populates normalized tables."
  (vulpea-test--with-temp-db
    (vulpea-db)
    (vulpea-db--insert-note
     :id "test-id"
     :path "/tmp/test.org"
     :level 0
     :pos 0
     :title "Test"
     :properties nil
     :tags '("wine" "red")
     :links '((:dest "other-id" :type "id"))
     :modified-at "2025-11-16")

    ;; Check tags table
    (let ((tags (emacsql (vulpea-db)
                         [:select [tag] :from tags
                          :where (= note-id $s1)
                          :order :by tag]
                         "test-id")))
      (should (equal tags '(("red") ("wine")))))

    ;; Check links table
    (let ((links (emacsql (vulpea-db)
                          [:select [dest type] :from links
                           :where (= source $s1)]
                          "test-id")))
      (should (equal links '(("other-id" "id")))))))

(ert-deftest vulpea-db-delete-cascades ()
  "Test deleting note cascades to normalized tables."
  (vulpea-test--with-temp-db
    (vulpea-db)
    (vulpea-db--insert-note
     :id "test-id"
     :path "/tmp/test.org"
     :level 0
     :pos 0
     :title "Test"
     :properties nil
     :tags '("tag1")
     :links '((:dest "other" :type "id"))
     :modified-at "2025-11-16")

    ;; Verify data exists
    (should (emacsql (vulpea-db)
                     [:select * :from tags :where (= note-id $s1)]
                     "test-id"))
    (should (emacsql (vulpea-db)
                     [:select * :from links :where (= source $s1)]
                     "test-id"))

    ;; Delete
    (vulpea-db--delete-file-notes "/tmp/test.org")

    ;; Verify cascade
    (should-not (emacsql (vulpea-db)
                         [:select * :from tags :where (= note-id $s1)]
                         "test-id"))
    (should-not (emacsql (vulpea-db)
                         [:select * :from links :where (= source $s1)]
                         "test-id"))))

;;; vulpea-db-test.el ends here
#+end_src

** Step 1.5: Run Tests

#+begin_src bash
# Run database tests
eldev test vulpea-db-test

# Check coverage (if available)
eldev test --coverage vulpea-db-test
#+end_src

* Phase 2: Query Layer

** Step 2.1: Create Query Module

Create =vulpea-db-query.el=:

#+begin_src elisp
;;; vulpea-db-query.el --- Query builders for Vulpea -*- lexical-binding: t; -*-

(require 'vulpea-db)
(require 'vulpea-note)

(defun vulpea-db--row-to-note (row)
  "Convert database ROW to vulpea-note struct."
  (pcase-let ((`[,id ,path ,level ,pos ,title ,properties
                 ,tags ,aliases ,meta ,links
                 ,todo ,priority ,scheduled ,deadline ,closed
                 ,outline-path ,attach-dir ,created-at ,modified-at]
               row))
    (make-vulpea-note
     :id id
     :path path
     :level level
     :title title
     :tags (when tags (json-parse-string tags :array-type 'list))
     :aliases (when aliases (json-parse-string aliases :array-type 'list))
     :properties (when properties (json-parse-string properties :object-type 'alist))
     :meta (when meta (json-parse-string meta :object-type 'alist))
     :links (when links (json-parse-string links :array-type 'list :object-type 'plist))
     :todo todo
     :priority priority
     :outline-path outline-path
     :attach-dir attach-dir)))

(defun vulpea-db-get-by-id (id)
  "Get note by ID.
Returns complete note from materialized table - no JOINs."
  (when-let ((row (caar (emacsql (vulpea-db)
                                 [:select * :from notes
                                  :where (= id $s1)]
                                 id))))
    (vulpea-db--row-to-note row)))

(defun vulpea-db-query (predicate)
  "Query all notes matching PREDICATE.
Loads all notes from materialized table, filters in Elisp."
  (let ((notes (mapcar #'vulpea-db--row-to-note
                       (emacsql (vulpea-db)
                                [:select * :from notes]))))
    (if predicate
        (seq-filter predicate notes)
      notes)))

(defun vulpea-db-query-by-tags-some (tags)
  "Get notes that have ANY of TAGS.
Uses normalized tags table for filtering."
  (if (null tags)
      nil
    (let ((rows (emacsql (vulpea-db)
                         [:select :distinct [notes:*]
                          :from notes
                          :inner :join tags
                          :on (= notes:id tags:note-id)
                          :where (in tags:tag $v1)]
                         (vconcat tags))))
      (mapcar #'vulpea-db--row-to-note rows))))

(defun vulpea-db-query-by-tags-every (tags)
  "Get notes that have ALL of TAGS.
Uses GROUP BY + HAVING for efficient filtering."
  (if (null tags)
      (vulpea-db-query nil)  ; Return all notes
    (let* ((tag-count (length tags))
           (note-ids (mapcar #'car
                             (emacsql (vulpea-db)
                                      [:select [note-id]
                                       :from tags
                                       :where (in tag $v1)
                                       :group :by note-id
                                       :having (= (:count :distinct tag) $s2)]
                                      (vconcat tags)
                                      tag-count))))
      (when note-ids
        (let ((rows (emacsql (vulpea-db)
                             [:select * :from notes
                              :where (in id $v1)]
                             (vconcat note-ids))))
          (mapcar #'vulpea-db--row-to-note rows))))))

(defun vulpea-db-query-by-tags-none (tags)
  "Get notes that have NONE of TAGS."
  (if (null tags)
      (vulpea-db-query nil)
    (let ((note-ids (mapcar #'car
                            (emacsql (vulpea-db)
                                     [:select [note-id]
                                      :from tags
                                      :where (in tag $v1)]
                                     (vconcat tags)))))
      (let ((rows (emacsql (vulpea-db)
                           [:select * :from notes
                            :where (not (in id $v1))]
                           (vconcat (or note-ids '(""))))))
        (mapcar #'vulpea-db--row-to-note rows)))))

(defun vulpea-db-query-by-links-some (dest-ids)
  "Get notes that link to ANY of DEST-IDS."
  (if (null dest-ids)
      nil
    (let ((rows (emacsql (vulpea-db)
                         [:select :distinct [notes:*]
                          :from notes
                          :inner :join links
                          :on (= notes:id links:source)
                          :where (in links:dest $v1)]
                         (vconcat dest-ids))))
      (mapcar #'vulpea-db--row-to-note rows))))

(defun vulpea-db-query-by-level (level)
  "Get all notes at LEVEL (0 = file-level, 1+ = heading)."
  (let ((rows (emacsql (vulpea-db)
                       [:select * :from notes
                        :where (= level $s1)]
                       level)))
    (mapcar #'vulpea-db--row-to-note rows)))

(defun vulpea-db-search-by-title (pattern)
  "Search notes by PATTERN in title."
  (let ((rows (emacsql (vulpea-db)
                       [:select * :from notes
                        :where (like title $s1)]
                       (format "%%%s%%" pattern))))
    (mapcar #'vulpea-db--row-to-note rows)))

(provide 'vulpea-db-query)
#+end_src

** Step 2.2: Write Query Tests

Add to =test/vulpea-db-test.el=:

#+begin_src elisp
(ert-deftest vulpea-db-get-by-id ()
  "Test getting note by ID."
  (vulpea-test--with-temp-db
    (vulpea-db)
    (vulpea-db--insert-note
     :id "test-id"
     :path "/tmp/test.org"
     :level 0
     :pos 0
     :title "Test Note"
     :properties nil
     :modified-at "2025-11-16")

    (let ((note (vulpea-db-get-by-id "test-id")))
      (should note)
      (should (equal (vulpea-note-id note) "test-id"))
      (should (equal (vulpea-note-title note) "Test Note")))))

(ert-deftest vulpea-db-query-by-tags-some ()
  "Test querying by tags (OR)."
  (vulpea-test--with-temp-db
    (vulpea-db)
    (vulpea-db--insert-note :id "note1" :tags '("wine" "red") ...)
    (vulpea-db--insert-note :id "note2" :tags '("wine" "white") ...)
    (vulpea-db--insert-note :id "note3" :tags '("work") ...)

    (let ((notes (vulpea-db-query-by-tags-some '("wine"))))
      (should (= (length notes) 2))
      (should (member "note1" (mapcar #'vulpea-note-id notes)))
      (should (member "note2" (mapcar #'vulpea-note-id notes))))))

(ert-deftest vulpea-db-query-by-tags-every ()
  "Test querying by tags (AND)."
  (vulpea-test--with-temp-db
    (vulpea-db)
    (vulpea-db--insert-note :id "note1" :tags '("wine" "red" "italy") ...)
    (vulpea-db--insert-note :id "note2" :tags '("wine" "red") ...)
    (vulpea-db--insert-note :id "note3" :tags '("wine" "white") ...)

    (let ((notes (vulpea-db-query-by-tags-every '("wine" "red"))))
      (should (= (length notes) 2))
      (should (member "note1" (mapcar #'vulpea-note-id notes)))
      (should (member "note2" (mapcar #'vulpea-note-id notes))))))
#+end_src

* Phase 3: Parser & Extractors

** Step 3.1: Parse Context

Create =vulpea-db-extract.el=:

#+begin_src elisp
;;; vulpea-db-extract.el --- Note extractors -*- lexical-binding: t; -*-

(require 'org-element)
(require 'vulpea-db)

(cl-defstruct vulpea-parse-ctx
  "Parse context shared across extractors."
  path          ; File path
  ast           ; Full org-element AST
  file-node     ; Top-level file information
  heading-nodes ; List of heading nodes (if enabled)
  hash          ; Content hash
  mtime         ; Modification time
  size)         ; File size

(defcustom vulpea-db-index-heading-level t
  "Whether to index heading-level notes.
Can be:
- t: index all headings
- nil: index only file-level
- function: predicate (path) -> boolean

For 100k+ notes, disabling heading-level indexing can provide
2-3x performance improvement."
  :type '(choice boolean function)
  :group 'vulpea-db)

(defun vulpea-db--parse-file (path)
  "Parse file at PATH and return parse context."
  (with-temp-buffer
    (insert-file-contents path)
    (org-mode)
    (org-set-regexps-and-options 'tags-only)
    (let* ((ast (org-element-parse-buffer))
           (file-node (vulpea-db--extract-file-node ast path))
           (heading-nodes
            (when (vulpea-db--should-index-headings-p path)
              (vulpea-db--extract-heading-nodes ast path))))
      (make-vulpea-parse-ctx
       :path path
       :ast ast
       :file-node file-node
       :heading-nodes heading-nodes
       :hash (secure-hash 'sha256 (buffer-string))
       :mtime (file-attribute-modification-time (file-attributes path))
       :size (buffer-size)))))

(defun vulpea-db--should-index-headings-p (path)
  "Check if headings should be indexed for PATH."
  (pcase vulpea-db-index-heading-level
    ('nil nil)
    ('t t)
    ((pred functionp) (funcall vulpea-db-index-heading-level path))
    (_ t)))

;; Continue with extractors...
#+end_src

See =docs/v2-architecture-decisions.org= for complete implementation.

* Development Workflow

** Running Tests
#+begin_src bash
# All tests
eldev test

# Specific test file
eldev test vulpea-db-test

# Specific test
eldev test vulpea-db-init

# With coverage
eldev test --coverage

# Performance tests only
eldev test --tags perf
#+end_src

** Linting
#+begin_src bash
# Byte-compile
eldev compile

# Lint
eldev lint

# Check package metadata
eldev doctor
#+end_src

** Benchmarking
#+begin_src bash
# Run performance suite
eldev test --tags benchmark

# Profile specific function
eldev exec emacs --batch -l test/vulpea-perf-test.el \
  -f vulpea-perf-profile-query-by-tags
#+end_src

* Next Steps

1. Read =v2-architecture-decisions.org= for full context
2. Start with Phase 1: Database Core
3. Write tests FIRST (TDD approach)
4. Measure performance at each phase
5. Document any deviations from plan

* Getting Help

- Architecture questions: See =v2-architecture-decisions.org=
- Implementation questions: This guide
- Performance issues: Check =test/vulpea-perf-test.el=
- Existing patterns: Reference current =vulpea-db.el=

Good luck! ðŸš€
